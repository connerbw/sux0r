http://www.sux0r.org/
All spelling mistakes are final and will not be refunded

### HACKER ###

http://en.wikipedia.org/wiki/Hacker_ethic
http://sourceforge.net/forum/forum.php?thread_id=2372082&forum_id=447217

### CONVENTIONS ###

Everything in and out of sux0r is UTF-8. Make sure your text editor correctly
loads and saves UTF-8. Make sure your databases are UTF-8. Make sure your CVS
client handles UTF-8. Make sure you use multi-byte UTF-8 compatible PHP
functions. Did we mention UTF-8? Yes we know ASCII is faster. Unfortunately the
world doesn't speak American, but we can all communicate with UTF-8.

If it's not in suxRenderer(), or in an extension of suxRenderer(), or a
template, then your HTML is in the wrong place. Keep your in-line out of the
sux0r project as much as possible.

English is the base language. All other languages override it. This allows for
lazy translations. If you see English on your non-English site, your language
files are probably incomplete. Optionally, hard-coded English has crept into a
template and it should be moved into a language file.

Skins are called partitions in sux0r. Partitioning falls back on the default
sux0r partition when what is being accessed can't be found . This allows for
the omission of template files you don't care about. Default sux0r templates
will be used instead. Conversely, every file in the sux0r media partition must
be duplicated when creating a new partition.

### FUTURE ###

I believe that threaded messages can represent several content paradigms,
for example:

Forum - the natural state of the threaded message.
Blog - initial post is a blog, all replies are comments.
Wiki - Initial post is a wiki, all comments are discussion.
Slideshow - like a powerpoint presentation, flow is ordered by thread.

Although sux0r 2.0 focuses on the blog, the framework for further development
is in place. Each suxThreadedMessage() is sanitized into both an HTML message
and a plain text version. Each edited suxThreadedMessage() saves a backup of
itself into a history table. The beginnings of a wiki would merely require a
clever implementation of a diff algorithm between the plaintext revisions,
which are already automatically generated on every edit.

